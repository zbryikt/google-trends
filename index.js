// Generated by LiveScript 1.3.1
var request, fs, bluebird, trend;
request = require('request');
fs = require('fs');
bluebird = require('bluebird');
trend = {
  init: function(data){
    var ret;
    if (!data) {
      data = fs.readFileSync('curl').toString();
    }
    ret = /-H 'cookie: ([^']+)'/.exec(data);
    if (!ret) {
      return this.config = {};
    } else {
      return this.config = {
        cookie: ret[1]
      };
    }
  },
  get: function(keywords){
    var length, this$ = this;
    length = 1;
    if (Array.isArray(keywords)) {
      length = keywords.length;
      keywords = keywords.splice(0, 5).join(',');
    }
    if (!this.config) {
      this.init();
    }
    return new bluebird(function(res, rej){
      return request({
        url: "http://www.google.com/trends/fetchComponent?q=" + encodeURIComponent(keywords) + "&cid=TIMESERIES_GRAPH_0&export=3",
        method: 'GET',
        headers: this$.config
      }, function(e, r, b){
        var mat, ret, keywords, choose, ref$, values, i$, len$, i, k;
        if (e || !b) {
          return rej(null);
        }
        mat = /google.visualization.Query.setResponse\((.+)\);/.exec(b);
        if (mat) {
          b = mat[1];
          ret = {};
          b = b.replace(/new Date\((\d+),(\d+),(\d+)\)/g, '"$1/$2/$3"');
          b = b.replace(/,,/g, ',');
          b = JSON.parse(b);
          keywords = b.table.cols.map(function(it){
            return it.label;
          }).splice(1);
          choose = 1;
          if ((ref$ = b.table.rows)[ref$.length - 1].c[1].v === null) {
            choose = 2;
          }
          values = (ref$ = b.table.rows)[ref$.length - choose].c.map(function(it){
            return it.v;
          }).splice(1);
          for (i$ = 0, len$ = keywords.length; i$ < len$; ++i$) {
            i = i$;
            k = keywords[i$];
            ret[k] = values[i];
          }
        } else {
          ret = {};
        }
        return res(ret);
      });
    });
  },
  join: function(pivot, hash, map){
    var k, results$ = [];
    if (!(pivot in map)) {
      return;
    }
    if (!(pivot in hash)) {
      hash[pivot] = 1;
    }
    for (k in map) {
      if (k !== pivot) {
        results$.push(hash[k] = hash[pivot] * (map[k] / map[pivot]));
      }
    }
    return results$;
  },
  normalize: function(hash){
    var min, k, results$ = [];
    min = Math.min.apply(null, (function(){
      var results$ = [];
      for (k in hash) {
        results$.push(hash[k]);
      }
      return results$;
    }()));
    for (k in hash) {
      results$.push(hash[k] = parseInt(100 * hash[k] / min) / 100);
    }
    return results$;
  },
  _getAllForPivot: function(pivot, list, hash, res, rej){
    var tag, this$ = this;
    if (list.length === 0) {
      return res(hash);
    }
    tag = list.splice(0, 1)[0];
    return this.get([pivot, tag]).then(function(map){
      this$.join(pivot, hash, map);
      return this$._getAllForPivot(pivot, list, hash, res, rej);
    })['catch'](rej);
  },
  getAllForPivot: function(pivot, list, hash){
    var this$ = this;
    return new bluebird(function(res, rej){
      return this$._getAllForPivot(pivot, list, hash, res, rej);
    });
  },
  _getAll: function(list, pivot, hash, res, rej){
    var this$ = this;
    pivot == null && (pivot = null);
    hash == null && (hash = {});
    if (list.length === 1 && !pivot) {
      return this.get(list).then(function(it){
        return res(it);
      });
    }
    if (list.length === 0 && !pivot) {
      return res(hash);
    }
    if (!pivot) {
      pivot = list.splice(0, 1)[0];
    }
    return this.getAllForPivot(pivot, list, hash).then(function(hash){
      var keys, res$, k, mins, maxs, order, minv, maxv;
      res$ = [];
      for (k in hash) {
        res$.push(k);
      }
      keys = res$;
      mins = keys.filter(function(it){
        return hash[it] === 0;
      });
      maxs = keys.filter(function(it){
        return hash[it] === Infinity;
      });
      order = (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = keys).length; i$ < len$; ++i$) {
          k = ref$[i$];
          results$.push([k, hash[k]]);
        }
        return results$;
      }()).filter(function(it){
        return it[1] !== 0 && isFinite(it[1]);
      }).sort(function(a, b){
        return a[1] - b[1];
      });
      minv = order[0];
      maxv = order[order.length - 1];
      if (mins.length && minv[0] !== pivot) {
        return this$.getAll(mins, minv[0], hash).then(function(){
          if (maxs.length && maxv[0] !== pivot) {
            return this$.getAll(maxs, maxv[0], hash).then(function(){
              return res(hash);
            })['catch'](rej);
          } else {
            return res(hash);
          }
        })['catch'](rej);
      } else if (maxs.length && maxv[0] !== pivot) {
        return this$.getAll(maxs, maxv[0], hash).then(function(){
          return res(hash);
        })['catch'](rej);
      } else {
        return res(hash);
      }
    })['catch'](rej);
  },
  getAll: function(list, pivot, hash){
    var this$ = this;
    pivot == null && (pivot = null);
    hash == null && (hash = {});
    return new bluebird(function(res, rej){
      return this$._getAll(list, pivot, hash, res, rej);
    });
  }
  /*
  _getAll: (pivot, list, hash, res, rej) ->
    if list.length == 0 => return res hash
    tag = list.splice 0,1 .0
    @get [pivot,tag] .then (map) ~> 
      if map[pivot] and isFinite(map[pivot]) => @merge hash, map
      @_getAll pivot, list, hash, res, rej
    .catch rej
  
  getAll: (list, pivot = null, hash = {}) ->
    _getAllPromisea [k for k in list], pivot, hash
    .then (hash) ~> 
      if [k for k of hash].length == list.length => #done
      for k in list => if !(k of hash) =>
  */
  /*
  updateHash: (hash, map) ->
    order = [k for k of map]map(->[it, map[it]]).sort((a,b)-> a.1 - b.1)
    if !order.length => return
    [mk, mv] = order.0
    if !hash[mk] => hash[mk] = 1
    for [k,v] in order =>
      if !hash[k] => hash[k] = (v / mv) * hash[mk]
  
  _getPivot: (pivot, list, hash, res, rej) ->
    if !pivot and !(list and list.length) => return rej!
    if !pivot => 
      pivot = list.splice 0,1 .0
      hash[pivot] = 1
    if list.length == 0 => return res {pivot,hash}
    tag = list.splice 0,1 .0
    @get [pivot,tag] .then (mapper) ~>
      if mapper[pivot] > mapper[tag] =>
        if mapper[tag] > 0 and hash[pivot] > 0 =>
          rate = mapper[pivot] / mapper[tag]
          for item of hash => hash[item] = hash[item] * rate
        pivot := tag
        hash[pivot] = 1
      else if mapper[pivot] > 0 and mapper[tag] > 0 =>
        hash[tag] = mapper[tag] / mapper[pivot]
      @_getPivot pivot, list, hash, res, rej
    .catch rej
  
  getPivot: (list) -> new bluebird (res, rej) ~> @_getPivot null, list, {}, res, rej
  
  _getAll: (pivot, list, hash, res, rej) ->
    if list.length == 0 => return res hash
    tag = list.splice 0,1 .0
    @get [pivot,tag] .then (mapper) ~> 
      if !hash[pivot] => hash[pivot] = mapper[pivot]
      hash[tag] = mapper[tag] * hash[pivot] / mapper[pivot]
      @_getAll pivot, list, hash, res, rej
    .catch rej
  
  getAll: (list) -> 
    (res, rej) <~ new bluebird _
    ({pivot, hash}) <~ @getPivot [k for k in list] .then
    if list.length == 1 => return res hash
    remains = []
    for key in list => if !(key of hash) => remains.push key
    @_getAll pivot, remains, hash, res, rej
  */,
  _align: function(v, len, float, char){
    var s, slen;
    float == null && (float = false);
    char == null && (char = " ");
    s = v + "";
    if (float) {
      slen = s.indexOf(".");
    }
    if (!float || slen < 0) {
      slen = s.length;
    }
    return repeatString$(char + "", len - slen) + (v + "");
  },
  format: function(list){
    var this$ = this;
    return this.getAll(list).then(function(hash){
      var keys, k, len, i$, len$, results$ = [];
      keys = (function(){
        var results$ = [];
        for (k in hash) {
          results$.push(k);
        }
        return results$;
      }()).sort(function(a, b){
        return hash[b] - hash[a];
      });
      len = Math.max.apply(null, keys.map(function(it){
        return it.length;
      }));
      for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
        k = keys[i$];
        results$.push(console.log(this$._align(k, len + 2), this$._align(parseInt(hash[k] * 100) / 100, 6, true)));
      }
      return results$;
    });
  }
};
module.exports = trend;
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}