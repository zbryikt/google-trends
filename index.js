// Generated by LiveScript 1.3.1
var request, fs, bluebird, cheerio, trend;
request = require('request');
fs = require('fs');
bluebird = require('bluebird');
cheerio = require('cheerio');
trend = {
  init: function(data){
    var ret;
    if (!data) {
      data = fs.readFileSync('curl').toString();
    }
    ret = /-H 'cookie: ([^']+)'/.exec(data);
    if (!ret) {
      return this.config = {};
    } else {
      return this.config = {
        cookie: ret[1]
      };
    }
  },
  _related: function(keywords, hash, res, rej){
    var keyword, this$ = this;
    if (keywords.length === 0) {
      return res(hash);
    }
    keyword = keywords.splice(0, 1)[0];
    return this.related(keyword).then(function(h){
      hash[keyword] = h;
      return this$._related(keywords, hash, res, rej);
    })['catch'](rej);
  },
  related: function(keyword){
    var this$ = this;
    if (typeof keyword === "object" && keyword.length) {
      return new bluebird(function(res, rej){
        return this$._related(keyword, {}, res, rej);
      });
    }
    if (!this.config) {
      this.init();
    }
    return new bluebird(function(res, rej){
      return request({
        url: "http://www.google.com.tw/trends/trendsReport?hl=zh-TW&q=" + encodeURIComponent(keyword) + "&cmpt=q&tz=&tz=&content=1",
        method: 'GET',
        headers: this$.config
      }, function(e, r, b){
        var $, ret, i$, ref$, len$, row, name, value;
        if (e || !b) {
          return rej(null);
        }
        $ = cheerio.load(b);
        ret = {};
        for (i$ = 0, len$ = (ref$ = $('#TOP_QUERIES_0_0table .trends-table-row')).length; i$ < len$; ++i$) {
          row = ref$[i$];
          name = $(row).find(".trends-bar-chart-name a:first-child").text().trim();
          value = parseInt($(row).find(".trends-hbars-value").text().trim());
          ret[name] = value;
        }
        return res(ret);
      });
    });
  },
  _recurse: function(keyword, hash, depth, lv, usedKeyword, res, rej){
    var this$ = this;
    return this.related(keyword).then(function(newHash){
      var list, k, newKeyword;
      usedKeyword.push(keyword);
      import$(hash, newHash);
      list = (function(){
        var results$ = [];
        for (k in hash) {
          results$.push(k);
        }
        return results$;
      }()).sort(function(a, b){
        return hash[b] - hash[a];
      });
      while (list.length) {
        newKeyword = list.splice(0, 1)[0];
        if (usedKeyword.indexOf(newKeyword) === -1) {
          break;
        }
      }
      if (usedKeyword.indexOf(newKeyword) >= 0 || lv >= depth) {
        return res(hash);
      } else {
        return this$._recurse(newKeyword, hash, depth, lv + 1, usedKeyword, res, rej);
      }
    })['catch'](rej);
  },
  recursiveRelated: function(keyword, depth){
    var this$ = this;
    depth == null && (depth = 1);
    return new bluebird(function(res, rej){
      return this$._recurse(keyword, {}, depth, 0, [], res, rej);
    });
  },
  get: function(keywords){
    var length, this$ = this;
    length = 1;
    if (Array.isArray(keywords)) {
      length = keywords.length;
      keywords = keywords.splice(0, 5).join(',');
    }
    if (!this.config) {
      this.init();
    }
    return new bluebird(function(res, rej){
      return request({
        url: "http://www.google.com/trends/fetchComponent?q=" + encodeURIComponent(keywords) + "&cid=TIMESERIES_GRAPH_0&export=3",
        method: 'GET',
        headers: this$.config
      }, function(e, r, b){
        var mat, ret, keywords, choose, ref$, values, i$, len$, i, k;
        if (e || !b) {
          return rej(null);
        }
        mat = /google.visualization.Query.setResponse\((.+)\);/.exec(b);
        if (mat) {
          b = mat[1];
          ret = {};
          b = b.replace(/new Date\((\d+),(\d+),(\d+)\)/g, '"$1/$2/$3"');
          b = b.replace(/,,/g, ',');
          b = JSON.parse(b);
          keywords = b.table.cols.map(function(it){
            return it.label;
          }).splice(1);
          choose = 1;
          if ((ref$ = b.table.rows)[ref$.length - 1].c[1].v === null) {
            choose = 2;
          }
          values = (ref$ = b.table.rows)[ref$.length - choose].c.map(function(it){
            return it.v;
          }).splice(1);
          for (i$ = 0, len$ = keywords.length; i$ < len$; ++i$) {
            i = i$;
            k = keywords[i$];
            ret[k] = values[i];
          }
        } else {
          ret = {};
        }
        return res(ret);
      });
    });
  },
  join: function(pivot, hash, map){
    var k, results$ = [];
    if (!(pivot in map)) {
      return;
    }
    if (!(pivot in hash)) {
      hash[pivot] = 1;
    }
    for (k in map) {
      if (k !== pivot) {
        results$.push(hash[k] = hash[pivot] * (map[k] / map[pivot]));
      }
    }
    return results$;
  },
  normalize: function(hash){
    var min, k, results$ = [];
    min = Math.min.apply(null, (function(){
      var results$ = [];
      for (k in hash) {
        results$.push(hash[k]);
      }
      return results$;
    }()));
    for (k in hash) {
      results$.push(hash[k] = parseInt(100 * hash[k] / min) / 100);
    }
    return results$;
  },
  _getAllForPivot: function(pivot, list, hash, res, rej){
    var tag, this$ = this;
    if (list.length === 0) {
      return res(hash);
    }
    tag = list.splice(0, 1)[0];
    return this.get([pivot, tag]).then(function(map){
      this$.join(pivot, hash, map);
      return this$._getAllForPivot(pivot, list, hash, res, rej);
    })['catch'](rej);
  },
  getAllForPivot: function(pivot, list, hash){
    var this$ = this;
    return new bluebird(function(res, rej){
      return this$._getAllForPivot(pivot, list, hash, res, rej);
    });
  },
  _getAll: function(list, pivot, hash, res, rej){
    var this$ = this;
    pivot == null && (pivot = null);
    hash == null && (hash = {});
    if (list.length === 1 && !pivot) {
      return this.get(list).then(function(it){
        return res(it);
      });
    }
    if (list.length === 0 && !pivot) {
      return res(hash);
    }
    if (!pivot) {
      pivot = list.splice(0, 1)[0];
    }
    return this.getAllForPivot(pivot, list, hash).then(function(hash){
      var keys, res$, k, mins, maxs, order, minv, maxv;
      res$ = [];
      for (k in hash) {
        res$.push(k);
      }
      keys = res$;
      mins = keys.filter(function(it){
        return hash[it] === 0;
      });
      maxs = keys.filter(function(it){
        return hash[it] === Infinity;
      });
      order = (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = keys).length; i$ < len$; ++i$) {
          k = ref$[i$];
          results$.push([k, hash[k]]);
        }
        return results$;
      }()).filter(function(it){
        return it[1] !== 0 && isFinite(it[1]);
      }).sort(function(a, b){
        return a[1] - b[1];
      });
      minv = order[0];
      maxv = order[order.length - 1];
      if (mins.length && minv[0] !== pivot) {
        return this$.getAll(mins, minv[0], hash).then(function(){
          if (maxs.length && maxv[0] !== pivot) {
            return this$.getAll(maxs, maxv[0], hash).then(function(){
              return res(hash);
            })['catch'](rej);
          } else {
            return res(hash);
          }
        })['catch'](rej);
      } else if (maxs.length && maxv[0] !== pivot) {
        return this$.getAll(maxs, maxv[0], hash).then(function(){
          return res(hash);
        })['catch'](rej);
      } else {
        return res(hash);
      }
    })['catch'](rej);
  },
  getAll: function(list, pivot, hash){
    var this$ = this;
    pivot == null && (pivot = null);
    hash == null && (hash = {});
    return new bluebird(function(res, rej){
      return this$._getAll(list, pivot, hash, res, rej);
    });
  },
  _align: function(v, len, float, char){
    var s, slen;
    float == null && (float = false);
    char == null && (char = " ");
    s = v + "";
    if (float) {
      slen = s.indexOf(".");
    }
    if (!float || slen < 0) {
      slen = s.length;
    }
    return repeatString$(char + "", len - slen) + (v + "");
  },
  format: function(list){
    var this$ = this;
    return this.getAll(list).then(function(hash){
      var keys, k, len, i$, len$, results$ = [];
      keys = (function(){
        var results$ = [];
        for (k in hash) {
          results$.push(k);
        }
        return results$;
      }()).sort(function(a, b){
        return hash[b] - hash[a];
      });
      len = Math.max.apply(null, keys.map(function(it){
        return it.length;
      }));
      for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
        k = keys[i$];
        results$.push(console.log(this$._align(k, len + 2), this$._align(parseInt(hash[k] * 100) / 100, 6, true)));
      }
      return results$;
    });
  }
};
module.exports = trend;
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}